{"componentChunkName":"component---src-templates-blog-post-js","path":"/2016-07-26-junit-5-with-spring-boot-plus-kotlin/","result":{"data":{"site":{"siteMetadata":{"title":"Mike Plummer","author":"Mike Plummer"}},"markdownRemark":{"id":"29beee8b-9977-53ba-8b4d-95c4e97b9ff8","html":"<blockquote>\n<p><em>This was originally posted at <a href=\"https://objectpartners.com/2016/07/26/junit-5-with-spring-boot-plus-kotlin/\">Object Partners</a></em></p>\n</blockquote>\n<p>This summer the JUnit team released a beta version of the next iteration, <a href=\"http://junit.org/junit5/\">version five</a>. This newest version adds a ton of new features that will be a welcome relief for JVM developers who have been dealing with the limitations and idiosyncrasies of version four over the past decade. I’ve put together an <a href=\"https://github.com/mike-plummer/junit5-springboot-kotlin\">example project</a> to learn about the new feature set and tried to summarize some of my favorites in this post.</p>\n<h1>Features of JUnit 5</h1>\n<p>Backwards Compatibility: One of the biggest concerns with any update is how it affects an existing baseline. One of the great features of version 5 is that it nicely coexists with any JUnit tests you already have. In fact, the platform supplies a special test runner that allows any version 5 test to be run as a version 4 test, albeit without some of the more advanced features. This allows a project to adopt the update and gradually migrate its test suite rather than forcing a ‘big bang’-style conversion.</p>\n<p><strong>Nesting:</strong> A common complaint of JUnit 4 tests is the relative difficulty of writing behavior-driven tests in the style of Cucumber or Jasmine (in the JavaScript arena). Behavior Driven Testing (BDT) aims to test software by focusing on desired activities and features rather than the more technical focus of traditional Test Driven Development (TDD). BDT writes tests in a more verbose style, typically structuring tests in logical groups using a natural language format. In JUnit 4 this often results in dauntingly-long unit test names and large amounts of repetition. JUnit 5 resolves many of these problems by supporting Nested tests.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">    <span class=\"token annotation builtin\">@Autowired</span> <span class=\"token keyword\">lateinit</span> <span class=\"token keyword\">var</span> dataBean<span class=\"token operator\">:</span> DataBean\n\n    <span class=\"token annotation builtin\">@Nested</span>\n    <span class=\"token keyword\">inner</span> <span class=\"token keyword\">class</span> <span class=\"token function\">dataBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation builtin\">@Nested</span>\n        <span class=\"token keyword\">inner</span> <span class=\"token keyword\">class</span> <span class=\"token function\">whenRetrievingData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation builtin\">@Test</span>\n            <span class=\"token keyword\">fun</span> <span class=\"token function\">returnsCorrectData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">assertEquals</span><span class=\"token punctuation\">(</span>dataBean<span class=\"token punctuation\">.</span><span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> expectedData<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Nested tests allow for easier decomposition of tests into individual units that can easily share setup logic and also display in the test report in a more logical, grouped structure. For example, the code segment above will result in a test that naturally describes the expected behavior ‘dataBean, when retrieving data, returns correct data’ while allowing each segment of that behavior to be expanded with additional tests.</p>\n<p><strong>Dynamic Tests:</strong> In many situations testsneed to react to generated data or are unwieldy to write manually. For this use case JUnit 4 supplied the concept of Parameterized tests and JUnit 5 replaces it with simpler Dynamic Tests.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">    <span class=\"token annotation builtin\">@TestFactory</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">valuesShouldIncludeAllStates</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Collection <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> STATES<span class=\"token punctuation\">.</span><span class=\"token function\">map</span> <span class=\"token punctuation\">{</span> state <span class=\"token operator\">-</span>&amp;gt<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">dynamicTest</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">assertTrue</span><span class=\"token punctuation\">(</span>values<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p>This short block generates 50 individual tests to validate that my dataset includes the names of all 50 US states. This mechanism works particularly well for data-driven testing but has one significant drawback: dynamic tests do not support Before/After lifecycle hooks the way that legacy Parameterized tests do. This is an unfortunate limitation and can be partially worked around using Nested tests, but if multiple dynamic tests share data it cannot be reset between tests.</p>\n<p><strong>Extension:</strong> Extensions replace much of the legacy ‘Runner’ construct by enabling easy enhancement and expansion of test capabilities. For example, extensions exist to automatically handle Spring and Mockito integration to help keep your tests clean and simple. By using extensions you can also neatly sidestep some of the limitations of test subclassing – multiple extensions can be applied to a single test.</p>\n<p><strong>Tags, Filtering, and Naming:</strong> Sometimes you only need to run a subset of tests, for example only those dealing with a particular service or functional path. Each test or block of tests can be tagged, and at runtime a subset of tags can be included or excluded from execution. In addition, sometimes a test needs a name that doesn’t conform with method naming conventions. An optional DisplayName can be supplied for each test to print out in the test reports which can help readability.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">    <span class=\"token annotation builtin\">@Test</span>\n    <span class=\"token annotation builtin\">@Tag</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"LoadTests\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation builtin\">@DisplayName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Very long test that is disabled by default\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">largeLoadTest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// TEST CONTENT</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Dependency Injection:</strong> Custom ParameterResolvers can be written that will be used to inject parameters into any constructors or test methods. This can help reduce boilerplate in your before/after lifecycle hooks and provides an easy way to swap out implementations when running tests against different back-ends. This is particularly useful if you’re using a Dependency Injection (DI) mechanism in your code like Guice or Java CDI as the ParameterResolver can hook into or replace many DI functions.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">    <span class=\"token annotation builtin\">@ExtendWith</span><span class=\"token punctuation\">(</span>TestTrackerResolver<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">class</span> DependencyInjectionTest <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation builtin\">@BeforeEach</span>\n        <span class=\"token keyword\">fun</span> <span class=\"token function\">setup</span><span class=\"token punctuation\">(</span>tracker<span class=\"token operator\">:</span> TestTracker<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            tracker<span class=\"token punctuation\">.</span>testCount<span class=\"token operator\">++</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation builtin\">@Test</span>\n        <span class=\"token keyword\">fun</span> <span class=\"token function\">testTracker</span><span class=\"token punctuation\">(</span>tracker<span class=\"token operator\">:</span> TestTracker<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">assertEquals</span><span class=\"token punctuation\">(</span>tracker<span class=\"token punctuation\">.</span>testCount<span class=\"token punctuation\">,</span> <span class=\"token number\">1L</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">/** ParameterResolver that automatically supplies a TestTracker object where requested in the tests above **/</span>\n    <span class=\"token keyword\">class</span> TestTrackerResolver<span class=\"token operator\">:</span> ParameterResolver <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">companion</span> <span class=\"token keyword\">object</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">val</span> tracker<span class=\"token operator\">:</span> TestTracker <span class=\"token operator\">=</span> <span class=\"token function\">TestTracker</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">/** Whether this ParameterResolver supports the requested Parameter **/</span>\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">supports</span><span class=\"token punctuation\">(</span>parameterContext<span class=\"token operator\">:</span> ParameterContext<span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> extensionContext<span class=\"token operator\">:</span> ExtensionContext<span class=\"token operator\">?</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Boolean <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> parameterContext<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>parameter<span class=\"token operator\">?</span><span class=\"token punctuation\">.</span>type <span class=\"token operator\">==</span> TestTracker<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">/** Supply a value for the requested Parameter. **/</span>\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>parameterContext<span class=\"token operator\">:</span> ParameterContext<span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> extensionContext<span class=\"token operator\">:</span> ExtensionContext<span class=\"token operator\">?</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Any<span class=\"token operator\">?</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> tracker\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Java 8:</strong> Many test constructs have been updated to be lambda-friendly, and others like dynamic tests are a natural fit to be driven from a Stream. One of my personal favorite features is the idea of Supplier-based messages – in legacy tests a failure message was compiled and generated before the test even ran, but in the new format the Supplier will only be called in the event of a failure. This helps speed up tests ever so slightly but more importantly allows easy re-use of method references to generate detailed and standardized messages.</p>\n<h1>Use with Spring Boot</h1>\n<p>Even though JUnit 5 is in beta it’s already easy to use in Spring Boot. An excellent <a href=\"https://github.com/sbrannen/spring-test-junit5\">JUnit Extension</a> supplies easy Spring integration including Autowiring. By using this extension and annotating with @SpringBootTest a test has a complete Spring context to work with. As of the time of this post that extension is not published out to a public repository, but the code can be pulled from GitHub and built manually in just a few minutes.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">    <span class=\"token annotation builtin\">@SpringBootTest</span>\n    <span class=\"token annotation builtin\">@ExtendWith</span><span class=\"token punctuation\">(</span>SpringExtension<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">class</span> DataBeanTest <span class=\"token operator\">:</span> <span class=\"token function\">ApplicationTest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token annotation builtin\">@Autowired</span> <span class=\"token keyword\">lateinit</span> <span class=\"token keyword\">var</span> dataBean<span class=\"token operator\">:</span> DataBean\n\n        <span class=\"token annotation builtin\">@Test</span>\n        <span class=\"token keyword\">fun</span> <span class=\"token function\">testAutowiring</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">assertNotNull</span><span class=\"token punctuation\">(</span>dataBean<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<h1>Spring Boot with Kotlin</h1>\n<p>Moving off the topic of JUnit, one of my favorite new languages in the JVM space is Kotlin. I’ve <a href=\"https://objectpartners.com/2016/02/23/an-introduction-to-kotlin/\">written a bit about it here before</a>, and given its great feature set I wanted to see how well it worked for writing a Spring Boot application and JUnit 5 tests. Short answer: it works great once you know all the tricks.</p>\n<h2>Defining the Application</h2>\n<p>As it is in Java, creating your SpringBoot application in Kotlin is easy and concise.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">    <span class=\"token annotation builtin\">@SpringBootApplication</span>\n    <span class=\"token annotation builtin\">@ComponentScan</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"com.objectpartners.plummer.junit5\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">open</span> <span class=\"token keyword\">class</span> Application\n\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>args<span class=\"token operator\">:</span> Array<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        SpringApplication<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span>Application<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span>java<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Defining a Bean</h2>\n<p>With a quick annotation a Kotlin class becomes a Spring-managed bean.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">    <span class=\"token keyword\">interface</span> FibonacciService <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">fun</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>max<span class=\"token operator\">:</span> Long<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation builtin\">@Component</span>\n    <span class=\"token keyword\">open</span> <span class=\"token keyword\">class</span> FibonacciServiceImpl<span class=\"token operator\">:</span> FibonacciService <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span>max<span class=\"token operator\">:</span> Long<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List <span class=\"token punctuation\">{</span>\n            Assert<span class=\"token punctuation\">.</span><span class=\"token function\">isTrue</span><span class=\"token punctuation\">(</span>max &amp;gt<span class=\"token punctuation\">;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">generateSequence</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0L</span> <span class=\"token keyword\">to</span> <span class=\"token number\">1L</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> previous <span class=\"token operator\">-</span>&amp;gt<span class=\"token punctuation\">;</span> previous<span class=\"token punctuation\">.</span>second <span class=\"token keyword\">to</span> previous<span class=\"token punctuation\">.</span>first <span class=\"token operator\">+</span> previous<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">takeWhile</span> <span class=\"token punctuation\">{</span> result <span class=\"token operator\">-</span>&amp;gt<span class=\"token punctuation\">;</span> result<span class=\"token punctuation\">.</span>second  result<span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Using a Bean</h2>\n<p>This is the only really tricky area. Kotlin’s null-safety rules can cause problems with Dependency Injection since those fields are by definition not initialized at the time of declaration. Early versions of the language forced you to work around this by either performing a faux-initialization at declaration or by using parameter-based injection rather than field-based, but now Kotlin has the ‘lateinit’ keyword. This indicates to the compiler that the field will be initialized at some point between declaration and usage and to make assumptions based on that guarantee. If a ‘lateinit’ field is not initialized prior to use a special exception will be thrown to identify the unsatisfied assumption.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\">    <span class=\"token annotation builtin\">@Autowired</span> <span class=\"token keyword\">lateinit</span> <span class=\"token keyword\">var</span> fibonacciSvc<span class=\"token operator\">:</span> FibonacciService</code></pre></div>\n<h1>Wrap Up</h1>\n<p>Hopefully this article has gotten you interested in checking out JUnit5 and maybe even giving Kotlin a try. JUnit may not be the most flexible or powerful testing framework out there but this newest version improves what continues to be the simplest, most-used testing platform for the JVM and is ideal for anyone who is looking to incrementally update an existing test suite or wants to write tests that are easy, familiar, and maintainable. Be sure to check out the <a href=\"https://github.com/mike-plummer/junit5-springboot-kotlin\">example project</a> to see these features in action as part of a SpringBoot Kotlin application. Happy coding!</p>","frontmatter":{"title":"JUnit 5 with Spring Boot (plus Kotlin)","date":"July 26, 2016"}}},"pageContext":{"slug":"/2016-07-26-junit-5-with-spring-boot-plus-kotlin/"}},"staticQueryHashes":[]}