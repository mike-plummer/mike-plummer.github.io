{"componentChunkName":"component---src-templates-blog-post-js","path":"/2015-04-21-interfacing-groovy-and-java-with-native-libraries/","result":{"data":{"site":{"siteMetadata":{"title":"Mike Plummer"}},"markdownRemark":{"id":"3cb7eb33-15b2-5213-ab05-bc5eab68bec5","html":"<blockquote>\n<p><em>This was originally posted at <a href=\"https://objectpartners.com/2015/04/21/interfacing-groovy-and-java-with-native-libraries/\">Object Partners</a></em></p>\n</blockquote>\n<p>As much as we hate to admit it, from time to time there are benefits to languages that operate outside the JVM. Whether it’s interfacing with hardware or simply being faster compiled code, C/C++ provide some advantages that Groovy just doesn’t have out of the box. Luckily for us there are plenty of ways we can have our cake and eat it too: Java has had the ability to execute Native code for quite a while, thus Groovy has it too.</p>\n<p>Most seasoned Java developers are already cringing as they read this – Java Native Interface (JNI) is the method Java supplies to interact with Native libraries and has a well-deserved reputation for being unwieldy and heavy on the boilerplate. Over the years a variety of new frameworks have arisen that take a lot of the effort out of JNI and go a long way towards reducing the “rinse-lather-repeat” code that unnecessarily clutters your baseline. I’ve coded up an example out on <a href=\"https://github.com/mike-plummer/NativeGroovy\">GitHub</a> that demonstrates three quick uses of two different frameworks that allow you to invoke C/C++ code from a Groovy or Java program – the code will give you the full story but I’ll hit the high points here.</p>\n<p>For this example I’m going to execute a very simple C program that simply prints a String to standard out – obviously this is a trivial piece of logic that doesn’t warrant a Native Library on its own but it helps keep things simple since we’re focusing on how to interface with a library.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">printValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\\n%s\\n\\n\"</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This function has a corresponding header file (which will be very important in just a minute):</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifndef</span> <span class=\"token expression\">nativegroovy_h__</span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">nativegroovy_h__</span></span>\n\n<span class=\"token keyword\">extern</span> <span class=\"token keyword\">void</span> <span class=\"token function\">printValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span><span class=\"token operator\">*</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span> <span class=\"token comment\">//nativegroovy_h__</span></span></code></pre></div>\n<p>Using GCC we can quickly compile this into a shared library (a .dll, .so, or .dylib depending on your flavor of OS). I won’t go into detail on this process, but included in the example is a <a href=\"https://github.com/mike-plummer/NativeGroovy/blob/master/buildLibrary.sh\">bash script</a> that attempts to compile the appropriate type based on your OS (assuming you’re on a Linux or Mac system).</p>\n<p>Great, so we have a shared library. Now what?</p>\n<p>The example makes use of two different frameworks: <a href=\"https://github.com/twall/jna\">JNA</a> and <a href=\"https://github.com/nativelibs4java/BridJ\">BridJ</a>. JNA (Java Native Access) is slightly older (no automatic support of generics) but more robust while BridJ is relatively new (generics support, potentially more performant depending on your setup) but is still a work in progress.</p>\n<p>The first approach from the example shows a manual setup of JNA. Being a smart person intimately familiar with C/C++ syntax (aren’t we all?) you can manually inspect the header file from above and create an interface that exactly matches the functions that the library supplies. This works best for simple datatypes for obvious reasons – Strings, ints, and floats but stay away from structs. Once we have that interface we can ask JNA to load the NativeLibrary and map it to an instance of the interface we just created and presto, any calls we make to the interface will get dispatched to the library to be executed.</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\"><span class=\"token comment\">//Define an Interface that exactly matches our header file</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">NativeExample</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Library</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">printValue</span><span class=\"token punctuation\">(</span>String value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//Load library into an instance of NativeInterface</span>\n<span class=\"token keyword\">def</span> nativeLibrary <span class=\"token operator\">=</span> Native<span class=\"token punctuation\">.</span><span class=\"token function\">loadLibrary</span><span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span><span class=\"token function\">getProperty</span><span class=\"token punctuation\">(</span><span class=\"token string\">'nativegroovy.library.path'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> NativeExample<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//Call method - JNA intercepts this and invokes the library for us</span>\nnativeLibrary<span class=\"token punctuation\">.</span><span class=\"token function\">printValue</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Go go gadget Manual JNA'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>This approach is fine for very simple functions, but what if you’re trying to map a very complex function or a large number of functions? Never fear, there are tools to help you. A really great library called <a href=\"https://github.com/nativelibs4java/JNAerator\">JNAerator</a> does all the work for you – all you have to do is pass in the header file to your library and it will automatically generate a JAR file containing all the interfaces and bindings that are necessary. I’ve extracted this step in the example project’s Gradle build script so that, once that JAR is created, our code ends up even more concise.</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\"><span class=\"token comment\">//Build a ByteBuffer - roughly analagous to a Pointer to memory block</span>\n<span class=\"token keyword\">def</span> value <span class=\"token operator\">=</span> ByteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">wrap</span><span class=\"token punctuation\">(</span>Native<span class=\"token punctuation\">.</span><span class=\"token function\">toByteArray</span><span class=\"token punctuation\">(</span><span class=\"token interpolation-string\"><span class=\"token string\">\"Go go gadget JNA\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//Tell JNA to build an interface to the Native Library</span>\n<span class=\"token keyword\">def</span> library <span class=\"token operator\">=</span> Native<span class=\"token punctuation\">.</span><span class=\"token function\">loadLibrary</span><span class=\"token punctuation\">(</span>NativegroovyLibrary<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//Pass the ByteBuffer to the Native Library function</span>\nlibrary<span class=\"token punctuation\">.</span><span class=\"token function\">printValue</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Concise, yes, but not quite as clean. ByteBuffer? Where did that come from? The unfortunate tradeoff of the auto-generation is that the code often comes out a bit more complicated than necessary. It takes a little more work to use, but saves tons of time up front.</p>\n<p>We just used JNAerator to create JNA bindings but the tool actually by default tries to create BridJ bindings which are typically a bit cleaner and more performant. By making a quick tweak to how we call JNAerator (again, done in the Gradle script) we generate another JAR that, internally, is quite a bit different and presents a much cleaner interface.</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\"><span class=\"token comment\">//Build a pointer to your String (turn it into a more C-like String)</span>\n<span class=\"token keyword\">def</span> value <span class=\"token operator\">=</span> Pointer<span class=\"token punctuation\">.</span><span class=\"token function\">pointerToString</span><span class=\"token punctuation\">(</span><span class=\"token interpolation-string\"><span class=\"token string\">\"Go go gadget BridJ\"</span></span><span class=\"token punctuation\">,</span> StringType<span class=\"token punctuation\">.</span>C<span class=\"token punctuation\">,</span> Charset<span class=\"token punctuation\">.</span><span class=\"token function\">defaultCharset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//Invoke native library method (with BridJ doing the heavy lifting)</span>\nNativegroovyLibrary<span class=\"token punctuation\">.</span><span class=\"token function\">printValue</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span></code></pre></div>\n<p>How cool is that? It only takes a couple lines of Groovy to execute a function in a shared library. Granted there’s an extra JAR floating around in your classpath for the bindings, but that code is safely packed away not polluting your baseline and you never once have to set eyes on it.</p>\n<p>In the example project if we call each of the three different Gradle tasks in order to perform Manual JNA, Auto-Bound JNA, and Auto-Bound BridJ we get the following sets of output:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ gradle -q runManualJNA\nGo go gadget Manual JNA\n$ gradle -q runBoundJNA\n…\nGo go gadget JNA\n$ gradle -q runBoundBridJ\n…\nGo go gadget BridJ</code></pre></div>\n<p>Three different executions of a shared library in a tiny little package. Now, before you get all giddy and decide to roll Native Library use into a future project you should be aware of the following shortcomings:</p>\n<ol>\n<li>Using native libraries breaks the central tenet of JVM languages – “write once, run anywhere”. Your code will only execute on systems that have the library installed.</li>\n<li>It’s difficult to analyze and test: static code analysis tools and unit tests likely won’t be able to effectively analyze libraries.</li>\n<li>You lose the protections of the JVM: you’re inherently stepping outside the sandbox so you lose the security protections it provides and you have to start thinking about memory management.</li>\n<li>Performance can be a problem: depending on how the bindings get set up and how you call the functions you could actually make things slower. Generally speaking, native calls are better left for complex functions that are called infrequently rather than high-volume simple functions.</li>\n</ol>\n<p>So there you have it – another simple way to get more done with Groovy. Questions, comments, concerns, compliments? Leave ‘em below. Otherwise, take a look at the example available on my <a href=\"https://github.com/mike-plummer/NativeGroovy\">GitHub</a>.</p>\n<p>Happy coding!</p>","frontmatter":{"title":"Interfacing Groovy (and Java) with Native Libraries","date":"April 21, 2015"}}},"pageContext":{"slug":"/2015-04-21-interfacing-groovy-and-java-with-native-libraries/"}},"staticQueryHashes":[]}