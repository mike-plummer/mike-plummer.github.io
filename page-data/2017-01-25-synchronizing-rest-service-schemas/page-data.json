{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2017-01-25-synchronizing-rest-service-schemas/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Mike Plummer"}},"markdownRemark":{"id":"4f17bec9-ef2f-583f-aa70-3d40e261f3b4","html":"<blockquote>\n<p><em>This was originally posted at <a href=\"https://objectpartners.com/2017/01/25/synchronizing-rest-service-schemas/\">Object Partners</a></em></p>\n</blockquote>\n<p>We’ve all been there: Your app deploys to production and you discover that something has stopped working because the services you depend on have renamed a field. In a REST service there is no static contract to bind to, which most of the time is a fantastic feature but can also expose you to big problems if your services team aren’t great communicators or don’t publish good release notes. In this post I’ll walk through a few methods I’ve used in the past to help bridge the gap between a JavaScript/TypeScript front-end and (mostly Java) backing REST services.</p>\n<p>If you want to jump straight to a code example a good portion of what’s discussed here can be seen in action in <a href=\"https://github.com/mike-plummer/service-schemas\">this example application</a>.</p>\n<h1>What are my options?</h1>\n<h2>Just use JavaScript on your server</h2>\n<p>Definitely the easiest solution is to share a single baseline with a web layer by using <a href=\"https://nodejs.org/en/\">Node</a> as your server backend, allowing you to share the exact same code server- and client-side. While this works well for simple applications it quickly falls apart in more complex environments, especially when you need to interface with multiple external systems or have complicated concurrency needs.</p>\n<h2>Custom Generated Schemas</h2>\n<p>The next option is to write a custom generator and parser to scan your code to generate metadata then use that data in your front end. Typically this centers around <a href=\"https://en.wikipedia.org/wiki/Reflection_(computer_programming)\">reflection</a>. This is the most flexible solution, but is brittle and labor intensive. Never forget, every new capability you write from scratch is a capability you have to write tests for. It can also be more difficult to manage since, depending on your build system, you may only be able to generate this sort of data at build-time. In my experience, this should be used as a last resort.</p>\n<h2>API Specifications: WADL, RAML, Swagger</h2>\n<p>Ever since <a href=\"https://en.wikipedia.org/wiki/SOAP\">SOAP</a> services went out of vogue there have been various tools out there to generate a service specification to replace the concept of the <a href=\"https://en.wikipedia.org/wiki/Web_Services_Description_Language\">WSDL</a>. One of the first was <a href=\"https://en.wikipedia.org/wiki/Web_Application_Description_Language\">WADL</a> (Web Application Description Language). In theory it works well but in practice it isn’t human-readable and often has trouble with more complex services especially when inheritance is involved. There are standalone libraries to generate a WADL and it’s a baked in capability to Jersey, but if you’re using <a href=\"http://projects.spring.io/spring-framework/\">Spring</a> or <a href=\"https://ratpack.io/\">Ratpack</a> you’ll have to hack something in. Technically tools like <a href=\"https://www.soapui.org/\">SoapUI</a> can parse and use WADL’s but I’ve never gotten it to work correctly, and there isn’t strong support for consuming a WADL in client code.</p>\n<p>The two newest iterations of the REST Specification concept are <a href=\"http://raml.org/\">RAML</a> and <a href=\"http://swagger.io/\">Swagger</a>, also known as the Open API Specification (AOS). From what I’ve seen, Swagger is the clear winner. There are just a few tools for RAML generation in languages like Ruby, Python, and JavaScript which leaves the vast majority of REST services out in the cold. Swagger specs, meanwhile, are incredibly easy to generate in almost any language. Since I do most of my work in <a href=\"http://projects.spring.io/spring-boot/\">Spring Boot</a> I like to use the <a href=\"https://springfox.github.io/springfox/\">SpringFox</a> library which handles generating a very nice Swagger spec and <a href=\"http://swagger.io/swagger-ui/\">API UI</a> for all of my Spring services.</p>\n<p>This is all well and good, but while documenting your API helps inform consumers of changes it doesn’t always lend itself to in-code consumption. Adapters can be written to try to convert from Swagger into a JavaScript model, but this is yet another bit of code to maintain and there is some loss of precision during the translation.</p>\n<h2>JSON Schema</h2>\n<p>Simply put: This is the tool designed for our problem. <a href=\"http://json-schema.org/\">JSONSchema</a> is a standard for describing a domain model in JSON that can be easily generated server-side at build-time or runtime and then used client-side in a variety of ways.</p>\n<p>For example, to generate a schema for this <a href=\"https://kotlinlang.org/\">Kotlin</a> class…</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> <span class=\"token function\">ExtendedForecast</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">override</span> <span class=\"token keyword\">var</span> id<span class=\"token operator\">:</span> Long<span class=\"token punctuation\">,</span>\n                       <span class=\"token keyword\">var</span> forecasts<span class=\"token operator\">:</span> MutableList<span class=\"token punctuation\">,</span>\n                       <span class=\"token keyword\">var</span> confidence<span class=\"token operator\">:</span> Confidence<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>…we can just add this code to our <a href=\"https://gradle.org/\">Gradle</a> script…</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\"><span class=\"token keyword\">def</span> jsonSchemaGenerator <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JsonSchemaGenerator</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectMapper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">def</span> schema <span class=\"token operator\">=</span> jsonSchemaGenerator<span class=\"token punctuation\">.</span><span class=\"token function\">generateJsonSchema</span><span class=\"token punctuation\">(</span>ExtendedForecast<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span><span class=\"token string gstring\">\"<span class=\"token expression\"><span class=\"token punctuation\">$</span><span class=\"token punctuation\">{</span>buildDir<span class=\"token punctuation\">}</span></span>/json-schema.json\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">withWriter</span><span class=\"token punctuation\">(</span><span class=\"token string\">'UTF-8'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> writer <span class=\"token operator\">-</span><span class=\"token operator\">&amp;</span>gt<span class=\"token punctuation\">;</span>\n    writer<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>schema<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>…to output a file like this that contains a JSON-formatted schema description.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token string-property property\">\"ExtendedForecast\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string-property property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"object\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string-property property\">\"additionalProperties\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string-property property\">\"properties\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string-property property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string-property property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"integer\"</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string-property property\">\"forecasts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string-property property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"array\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string-property property\">\"items\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string-property property\">\"$ref\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"#/definitions/WeatherForecast\"</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string-property property\">\"confidence\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token string-property property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string-property property\">\"enum\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token string\">\"HIGH\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"MEDIUM\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token string\">\"LOW\"</span>\n      <span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>How you use it in your webapp is up to you. I’ve seen it used to generate TypeScript schemas, dynamically loaded at runtime to validate data structures, and used to auto-generate type-checked AJAX interfaces.</p>\n<p>And yet, it isn’t perfect. Interfaces and Abstract classes are not exposed with default generators, leaving you to write some custom configuration if that data is needed. Typically these structures are what give disparate concrete classes context relative to one another, so it’s information that is often very useful to have if only to help with ‘instanceof’ checks in your front-end. It also relies on a <a href=\"https://github.com/FasterXML/jackson-annotations\">correctly-annotated set of Jackson DTOs</a> or some more custom code to find and list all classes to generate schemas for.</p>\n<h2>On the Horizon</h2>\n<p>One of the things I’m most excited to see is the continued improvement in <a href=\"https://kotlinlang.org/\">Kotlin</a>. If you haven’t heard of it before Kotlin is (yet another) JVM language with some very neat features but also has a hidden superpower – it can compile directly to JavaScript. This means that you can define your model and use it in your server-side code but then build it as a set of JavaScript classes. This isn’t just limited to entity definitions though. How many times have you had to write the same function in client and server code? In addition to your domain model you can also share common utility code.</p>\n<p>Take for example this simple utility function. Its sole purpose is to serve as a customizable counter.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">object</span> counter <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> value<span class=\"token operator\">:</span> Long <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">incrementCounter</span><span class=\"token punctuation\">(</span>step<span class=\"token operator\">:</span> Long <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Long <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Stepping counter by </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">step</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span>\n    counter<span class=\"token punctuation\">.</span>value <span class=\"token operator\">+=</span> step\n    <span class=\"token keyword\">return</span> counter<span class=\"token punctuation\">.</span>value\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>After running this through the KotlinJS compiler we get the exact same capability delivered in a JavaScript function.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> counter_instance <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  counter_instance <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> Kotlin<span class=\"token punctuation\">.</span>Long<span class=\"token punctuation\">.</span><span class=\"token constant\">ZERO</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">counter_getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>counter_instance <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    counter_instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> counter_instance<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">incrementCounter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">step</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> tmp$<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>step <span class=\"token operator\">===</span> <span class=\"token keyword\">void</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    step <span class=\"token operator\">=</span> Kotlin<span class=\"token punctuation\">.</span>Long<span class=\"token punctuation\">.</span><span class=\"token constant\">ONE</span><span class=\"token punctuation\">;</span>\n  Kotlin<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Stepping counter by '</span> <span class=\"token operator\">+</span> step<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  tmp$ <span class=\"token operator\">=</span> <span class=\"token function\">counter_getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  tmp$<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> tmp$<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>step<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">counter_getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>No muss, no fuss. Plus, if we ever decide to change the behavior of this function we only have to update the Kotlin source and the corresponding JavaScript will be automatically generated the next time we build.</p>\n<p>That said, Kotlin is not a perfect choice. There are still quite a few rough edges since it’s such a new capability:</p>\n<ul>\n<li>Generated JavaScript is only ES5. No ES6/ES2015 features yet.</li>\n<li>Kotlin reflective capabilities not yet implemented in JavaScript code. Inheritance checks and field/function scanning still requires manual JavaScript code. This also means that field datatypes cannot be determined using the schema.</li>\n<li>Yet another JavaScript library to load that isn’t exactly tiny (~600 KB minified), but it does give you access to a large chunk of Kotlin’s capabilities and standard library.</li>\n</ul>\n<h1>So which should I use?</h1>\n<p>The answer to that question depends on your use case.</p>\n<p><strong>Document your API:</strong> Swagger is your best option. It’s a fantastic tool not only for documenting your services, but a Swagger specification can also be used to auto-generate client code that complies with your contracts. In addition, <a href=\"http://swagger.io/swagger-ui/\">SwaggerUI</a> supplies a very nice tool for exercising your services from the browser which is invaluable as a debug and testing capability.</p>\n<p><strong>Internal-use API:</strong> Consider publishing a more formal schema like a Java client JAR or JSON Schema in addition to Swagger. This gives consumers more flexibility for integrating since not every client will be able to use a Swagger spec.</p>\n<p><strong>Full-stack application:</strong> JSON Schema plus Swagger is a solid choice, but you may want to take a look at Kotlin. Odds are the same developers will be working front- and back-end, and nothing is more frustrating than having to rewrite the same utility functions in two places in two languages and keep them in sync. Kotlin saves time and reduces risk by combining those tasks into one.</p>\n<h1>Implementation</h1>\n<p>So, now that you’ve picked a strategy you need to determine how you’re going to generate and publish the information. There are a few different strategies that I’ve seen used and each has some positives and negatives.</p>\n<h2>When to generate?</h2>\n<p><strong>Build Time:</strong> Generating your schema as part of your build process is typically the easiest and fastest solution to implement. It also helps keep your deployable code ‘clean’ since it doesn’t have to have any knowledge or make allowances for the generation process. However, this approach does mean your real and published schemas can drift if you don’t tie the generation into your build tightly enough, plus you’re left with a set of files that you need to find a way to publish.</p>\n<p><strong>Run Time:</strong> This is typically more complex. Performing classpath scanning or other dynamic methods can also impact memory and CPU usage. However, there is a guarantee that your schema will not drift from your deployed baseline and minimizes the generated artifacts you have to manage in your build process.</p>\n<h2>How to publish?</h2>\n<p><strong>Resource Artifact:</strong> Generating a file or files that can be included in other projects is the simplest and most compatible solution, but it can be difficult to manage versions and leaves some uncertainty that the schema being used matches the service instance that will be interfaced with.</p>\n<p><strong>Co-deployment as service:</strong> Increases the size and complexity of your application bundle, but guarantees that your published schema stays in sync with your services.</p>\n<p><strong>Separate deployment as service:</strong> Keeps your application bundle simple and clean, but can get out of sync with your deployed services which defeats the purpose of publishing a schema in the first place.</p>\n<h1>Wrap Up</h1>\n<p>I’ve implemented some of these schema strategies discussed here in a <a href=\"https://github.com/mike-plummer/service-schemas\">simple example out on GitHub</a>. It’s just a simple <a href=\"https://angular.io/\">Angular2</a> app with some Gradle scripts that generate a manual, JSON, and Kotlin schema off the same baseline. It should give you a starting point for experimenting with some of these concepts. As I said, these are just some of the strategies I’ve seen used, but there are doubtless many more each with their own pros and cons.</p>\n<p>Happy coding!</p>","frontmatter":{"title":"Synchronizing Rest Service Schemas","date":"January 25, 2017"}}},"pageContext":{"slug":"/2017-01-25-synchronizing-rest-service-schemas/"}},
    "staticQueryHashes": []}